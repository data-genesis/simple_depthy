<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Depthy - 3D Parallax Video Generator</title>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@1.5.3/bin/pixi.min.js"></script>
  <script src="depth-perspective-filter.js"></script>
  <style>
    /* [–≤–µ—Å—å —Ç–≤–æ–π CSS –æ—Å—Ç–∞—ë—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π] */
  </style>
</head>
<body>
  <div class="header">
    <h1>Simple Depthy</h1>
  </div>

  <div class="container">
    <div class="upload-zone">
      <h3 style="margin-bottom: 15px;">Upload Files</h3>

      <div class="upload-area" id="imageUpload">
        <input type="file" id="imageInput" accept="image/jpeg,image/png">
        <p style="margin-bottom: 5px;">üì∑ Main Image</p>
        <p style="font-size: 12px; color: #666;">Drag & Drop or Click</p>
        <img class="upload-preview" id="imagePreview" alt="Main image preview">
      </div>

      <div class="upload-area" id="depthUpload">
        <input type="file" id="depthInput" accept="image/jpeg,image/png">
        <p style="margin-bottom: 5px;">üóòÔ∏è Depth Map</p>
        <p style="font-size: 12px; color: #666;">Grayscale image</p>
        <img class="upload-preview" id="depthPreview" alt="Depth map preview">
      </div>

      <div class="error-message" id="errorMessage"></div>
    </div>

    <div class="preview-window">
      <canvas id="previewCanvas">Your browser does not support canvas.</canvas>
    </div>

    <div class="controls">
      <h3 style="margin-bottom: 20px;">3D Effect Settings</h3>

      <div class="control-group">
        <label>Effect Strength</label>
        <div class="slider-container">
          <input type="range" id="strengthSlider" min="0" max="100" value="50">
          <span class="value-display" id="strengthValue">50%</span>
        </div>
      </div>

      <div class="control-group">
        <label>Animation Speed</label>
        <div class="slider-container">
          <input type="range" id="speedSlider" min="10" max="300" value="100">
          <span class="value-display" id="speedValue">1.0x</span>
        </div>
      </div>

      <div class="control-group">
        <label>Motion Radius</label>
        <div class="slider-container">
          <input type="range" id="radiusSlider" min="10" max="100" value="50">
          <span class="value-display" id="radiusValue">50</span>
        </div>
      </div>
    </div>

    <div class="export-panel">
      <h3 style="margin-bottom: 20px;">Export Video</h3>

      <div class="export-options">
        <div>
          <label style="display: block; margin-bottom: 5px; font-size: 14px; color: #aaa;">Duration</label>
          <select id="durationSelect">
            <option value="3">3 seconds</option>
            <option value="5" selected>5 seconds</option>
            <option value="10">10 seconds</option>
          </select>
        </div>

        <div>
          <label style="display: block; margin-bottom: 5px; font-size: 14px; color: #aaa;">Resolution</label>
          <select id="resolutionSelect">
            <option value="1080" selected>1080p (1920x1080)</option>
            <option value="1440">2K (2560x1440)</option>
          </select>
        </div>

        <div>
          <label style="display: block; margin-bottom: 5px; font-size: 14px; color: #aaa;">FPS</label>
          <select id="fpsSelect">
            <option value="30" selected>30 FPS</option>
            <option value="60">60 FPS</option>
          </select>
        </div>

        <div>
          <label style="display: block; margin-bottom: 5px; font-size: 14px; color: #aaa;">Format</label>
          <select id="formatSelect">
            <option value="mp4" selected>MP4</option>
            <option value="webm">WebM</option>
          </select>
        </div>
      </div>

      <button class="export-button" id="exportButton" disabled>Export Video</button>

      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="progress-text" id="progressText">Processing...</div>
    </div>
  </div>

  <script>
    let mainImage = null;
    let depthMap = null;
    let animationFrame = null;
    let isExporting = false;

    const imageUpload = document.getElementById('imageUpload');
    const depthUpload = document.getElementById('depthUpload');
    const imageInput = document.getElementById('imageInput');
    const depthInput = document.getElementById('depthInput');
    const imagePreview = document.getElementById('imagePreview');
    const depthPreview = document.getElementById('depthPreview');
    const previewCanvas = document.getElementById('previewCanvas');
    let renderer = null, stage = null, mesh = null, depthFilter = null;
    const errorMessage = document.getElementById('errorMessage');
    const exportButton = document.getElementById('exportButton');
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');

    const strengthSlider = document.getElementById('strengthSlider');
    const speedSlider = document.getElementById('speedSlider');
    const radiusSlider = document.getElementById('radiusSlider');
    const strengthValue = document.getElementById('strengthValue');
    const speedValue = document.getElementById('speedValue');
    const radiusValue = document.getElementById('radiusValue');

    function setupUploadHandlers(uploadArea, input, preview, callback) {
      uploadArea.addEventListener('click', () => input.click());
      uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragging'); });
      uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragging'));
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragging');
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) handleFile(file, preview, callback);
      });
      input.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) handleFile(file, preview, callback);
      });
    }

    function handleFile(file, preview, callback) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          preview.src = e.target.result;
          preview.style.display = 'block';
          callback(img);
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function processDepthMap() {
      if (!depthMap) return;
      const canvas = document.createElement('canvas');
      canvas.width = depthMap.width;
      canvas.height = depthMap.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(depthMap, 0, 0);
      ctx.getImageData(0, 0, depthMap.width, depthMap.height);
    }

    function validateAndStart() {
      errorMessage.style.display = 'none';
      if (!mainImage || !depthMap) return;
      if (mainImage.width !== depthMap.width || mainImage.height !== depthMap.height) {
        showError('Image dimensions must match depth map dimensions');
        return;
      }
      exportButton.disabled = false;
      initPixi();
      startAnimation();
    }

    function showError(msg) {
      errorMessage.textContent = msg;
      errorMessage.style.display = 'block';
    }

    function initPixi() {
      const width = mainImage.width;
      const height = mainImage.height;
      if (!renderer) {
        renderer = PIXI.autoDetectRenderer(width, height, { view: previewCanvas, antialias: true, transparent: false });
      } else {
        renderer.resize(width, height);
      }
      stage = new PIXI.Stage(0x000000);
      const baseTexture = new PIXI.BaseTexture(mainImage);
      const colorTexture = new PIXI.Texture(baseTexture);
      const depthBase = new PIXI.BaseTexture(depthMap);
      const depthTexture = new PIXI.Texture(depthBase);
      mesh = new PIXI.Sprite(colorTexture);
      depthFilter = new PIXI.DepthPerspectiveFilter(depthTexture, 4);
      mesh.filters = [depthFilter];
      stage.addChild(mesh);
    }

    function startAnimation() {
      if (animationFrame) cancelAnimationFrame(animationFrame);
      const startTime = Date.now();
      function animate() {
        if (!mainImage || !stage || isExporting) {
          animationFrame = requestAnimationFrame(animate);
          return;
        }
        const elapsed = (Date.now() - startTime) / 1000;
        renderFrame(elapsed);
        animationFrame = requestAnimationFrame(animate);
      }
      animate();
    }

    function renderFrame(time) {
      if (!stage) return;
      const strength = parseFloat(strengthSlider.value) / 100;
      const speed = parseFloat(speedSlider.value) / 100;
      const radius = parseFloat(radiusSlider.value);
      depthFilter.scale = 0.02 * strength;
      const offX = Math.sin(time * speed) * radius;
      const offY = Math.cos(time * speed) * radius * 0.5;
      depthFilter.offset = { x: offX, y: offY };
      renderer.render(stage);
    }

    async function exportVideo() {
      if (isExporting) return;
      isExporting = true;
      exportButton.disabled = true;
      progressBar.style.display = 'block';
      progressText.style.display = 'block';
      const duration = parseInt(document.getElementById('durationSelect').value);
      const resolution = document.getElementById('resolutionSelect').value;
      const fps = parseInt(document.getElementById('fpsSelect').value);
      const format = document.getElementById('formatSelect').value;
      const exportWidth = resolution === '1080' ? 1920 : 2560;
      const exportHeight = resolution === '1080' ? 1080 : 1440;
      const originalWidth = renderer.width;
      const originalHeight = renderer.height;
      renderer.resize(exportWidth, exportHeight);
      const stream = renderer.view.captureStream(fps);
      let options = { mimeType: format === 'mp4' ? 'video/mp4' : 'video/webm' };
      if (!MediaRecorder.isTypeSupported(options.mimeType)) options.mimeType = 'video/webm';
      const recorder = new MediaRecorder(stream, options);
      const chunks = [];
      recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
      recorder.onstop = () => {
        const blob = new Blob(chunks, { type: options.mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `depthy_${Date.now()}.${format}`;
        a.click();
        URL.revokeObjectURL(url);
        isExporting = false;
        exportButton.disabled = false;
        progressBar.style.display = 'none';
        progressText.style.display = 'none';
        progressFill.style.width = '0%';
      };
      recorder.start();
      const totalFrames = duration * fps;
      let currentFrame = 0;
      function renderExportFrame() {
        if (currentFrame >= totalFrames) {
          recorder.stop();
          renderer.resize(originalWidth, originalHeight);
          return;
        }
        const progress = (currentFrame / totalFrames) * 100;
        progressFill.style.width = `${progress}%`;
        progressText.textContent = `Processing... ${Math.round(progress)}%`;
        renderFrame(currentFrame / fps);
        currentFrame++;
        setTimeout(renderExportFrame, 1000 / fps);
      }
      renderExportFrame();
    }

    strengthSlider.addEventListener('input', e => strengthValue.textContent = `${e.target.value}%`);
    speedSlider.addEventListener('input', e => speedValue.textContent = `${(e.target.value / 100).toFixed(1)}x`);
    radiusSlider.addEventListener('input', e => radiusValue.textContent = e.target.value);
    exportButton.addEventListener('click', exportVideo);

    setupUploadHandlers(imageUpload, imageInput, imagePreview, img => { mainImage = img; validateAndStart(); });
    setupUploadHandlers(depthUpload, depthInput, depthPreview, img => { depthMap = img; processDepthMap(); validateAndStart(); });

    window.addEventListener('load', () => {
      if (!window.MediaRecorder) {
        showError('Your browser does not support video recording. Please use a modern browser.');
      }
    });
  </script>
</body>
</html>
